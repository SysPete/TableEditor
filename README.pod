=encoding utf8

=pod
 
=head1 NAME
 
Dancer - Table Edit
 
=head1 SYNOPSIS
 
Table Edit lets you edit database data. It uses L<DBIx::Class> models for database metadata. 

 
=head1 CONFIGURATION
 
You need a database and L<DBIx::Class> models for this module to work. You can 
write your own L<DBIx::Class> models, or use schema loader.


=head2 DBIx schema loader

You can use your existing DBIx schema or let schema loader make one for you.

=head2 Database config

You also have to set the DBIC connection details in the
Dancer configuration (usually in the environments/*.yml
files as this differs between systems).

	plugins: 
	   DBIC:
	     default:
	        dsn: dbi:Pg:dbname=__DATABASE_NAME__;host=localhost;port=__PORT__
	        schema_class: TableEdit::Schema
	        user: __USERNAME__
	        pass: __PASSWORD__
	        options:
               pg_enable_utf8: 1

Make sure that you are using the appropriate UTF-8 flag for L<Dancer::Plugin::DBIC>, as
this plugin doesn't set it automatically.

=head1 FRONTEND

Table Edit uses L<Angular|http://angularjs.org/Angular> and L<Bootstrap|http://getbootstrap.com/> for the frontend.
It is easy to change the Bootstrap theme to get a different look for Table Edit.

=head1 USE

With basic configuration done you can start using Table Edit. You will probably want to fine tune it a bit though.

=head1 FINE TUNE

Make sure you set all additional info below # DO NOT MODIFY THIS OR ANYTHING ABOVE! line in L<DBIx::Class> model.

For this example we will use following model.

	use utf8;
	package TableEdit::Schema::Result::User;
	
	use strict;
	use warnings;
	
	use base 'DBIx::Class::Core';
	
	__PACKAGE__->table("user");
	
	__PACKAGE__->add_columns(
	  "id",
	  { data_type => "integer", is_auto_increment => 1, is_nullable => 0 },
	  "username",
	  { data_type => "varchar", is_nullable => 0, size => 45 },
	  "email",
	  { data_type => "varchar", is_nullable => 1, size => 90 },
	  "birthday",
	  { data_type => "timestamp with time zone", is_nullable => 1 },
	  "internal_code",
	  { data_type => "integer", is_nullable => 1 },
	  "created_date",
	  {
	    data_type     => "timestamp with time zone",
	    default_value => \"current_timestamp",
	    is_nullable   => 0,
	    original      => { default_value => \"now()" },
	  },
	);
	
	__PACKAGE__->set_primary_key("id");
	
	__PACKAGE__->belongs_to(
	  "company",
	  "TableEdit::Schema::Result::Company",
	  { id => "podjetje_id" },
	  { is_deferrable => 1, on_delete => "CASCADE", on_update => "CASCADE" },
	);
	
	__PACKAGE__->has_many(
	  "user_items",
	  "TableEdit::Schema::Result::UserItem",
	  { "foreign.approval_id" => "self.approval_id" },
	  { cascade_copy => 0, cascade_delete => 0 },
	);
		
	__PACKAGE__->many_to_many("items", "user_items", "id", {class=>"Item",});
	
	# Created by DBIx::Class::Schema::Loader v0.07033
	# DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:g5NE5itWUoKXqfEKXj/8Rg
	
	__PACKAGE__->resultset_attributes({ 	
		label => 'Employees',
		grid_columns => ['id', 'username', 'email'],
		form_columns => ['id', 'username', 'email', 'birthday', 'internal_code'],
		many_to_many => {
			items => {class => 'TableEdit::Schema::Result::Item', where => {inactive => 'false'}},  
		},	
	});
	
	__PACKAGE__->columns_info->{created_date}->{readonly} = 1;
	__PACKAGE__->columns_info->{internal_code}->{hidden} = 1;
	__PACKAGE__->columns_info->{email}->{field_type} = 'text';
	
	# You can replace this text with custom code or comments, and it will be preserved on regeneration
	1;
		

=head2 Column label

You can override column label by specifying it  

	__PACKAGE__->columns_info->{fname}->{label} = 'Name';

=head2 Object / Row string representation

Row often has to be represented as string (titles, drop-down selectors, ...) so it is a good idea to 
define a custom, human readable stringification method. For example users username, his id in parentheses 
and company if he / she has one. It could be just username or something much complicated.

	use overload fallback => 1, '""' => \&to_string; 

	sub to_string {
		my $self = shift;	
		my $company = $self->company || "";
		return "$self->username ($self->id) $company";
	}

=head2 Hidden columns

Some columns are used only internally and you never want to see them in TableEdit. You can hide them.

	__PACKAGE__->columns_info->{internal_code}->{hidden} = 1;

=head2 Readonly columns

You can set a column to be readonly

	__PACKAGE__->columns_info->{created_date}->{readonly} = 1;

=head2 Many to many

"Has many" and "belongs_to" is automatically detected. However, many to many DBIx::Class information 
doesn't provide enough information, so you have to specify it manually.
Only set resultset_attributes once, or it will be overwritten! 

	__PACKAGE__->resultset_attributes({ 
		many_to_many => {
			items => {class => 'TableEdit::Schema::Result::Item', where => {inactive => 'false'}},  
		},		
	});
	
=head2 Grid / form visible columns

Often you don't care about all columns when you browse though rows or there are simply to many. 
You can specify a list of columns that will appear on grid or form. 
You have to be careful not to omit required columns and similar on form view.

	__PACKAGE__->resultset_attributes({ 	
		grid_columns => ['id', 'username', 'email'],
		form_columns => ['id', 'username', 'email', 'birthday', 'internal_code'],
	});
	
=head2 Model name / label

You can set user friendly name of the table.

	__PACKAGE__->resultset_attributes({ 	
		label => 'Employees',
	});
	
=head2 Field data type

Fields have basic field types based on data types in db. You can override them to use different form element.

	__PACKAGE__->columns_info->{email}->{field_type} = 'text';
	__PACKAGE__->columns_info->{description}->{field_type} = 'html';
	
You can also set them to use your custom widget. You create a HTML file with the matching name in F<public/views/field> directory.

For example F<public/views/field/email_widget.html>:
	
	__PACKAGE__->columns_info->{email}->{field_type} = 'email_widget';
	
These field types are used on detail view and on list search. 	
	
=head3 Built-in types

TE has some common types built in. Type 'html' is wysiwyg editor in text area. You can find other in F<public/views/field>.
 
=head1 PLUGINS
 
New functionalities and customization can be achieved by adding plugins.

=head2 Adding plugin

All plugins are located in /Plugins/name_of_plugin dir. Inside they usually have following stucture:

	Plugins
	|-Some_plugin
		|-api.pm
		|-public
			|-images
			|-js
				|-app.js
			|-views
	
URL to images folder is: 
api/plugins/Locator/public/images/

=head2 Activating plugin

Active plugins are listed in config.

	table_editor_plugins: [ "SomePlugin", "SomeOtherPlugin" ]

=head2 Custom pages

You can add new or redefine any page by adding custom route and redirect it to custom controller (or leave default) and custom template (or default). In js/app.js.

	custom_routes['/User/edit/:id'] = { templateUrl: '/api/plugins/SomePlugin/public/views/user-form.html', controller: 'UserEditCtrl' };
	
	var UserEditCtrl = function ($scope, $rootScope, $routeParams, Item, ClassItem, Url) {
		$scope.item = Item.read.get({
			class: 'User', 
			id: $routeParams.id}
		);
		$scope.data = ClassItem.get({class: 'User'});

		$scope.save = Item.update;
		$scope.related = Item.related_link;
	};

=head2 Custom API 

In api.pm routes can be overridden. This is useful for data manipulation before saving, data validation, custom information or similar. 


Example usage:

	package TableEdit::Plugins::SomePlugin::API;
	use Dancer ':syntax';


	prefix '/api';

	# Data validation
	post '/User' => sub {		
		my $post_data = from_json request->body;
		my $values = $post_data->{item}->{values};
		unless ($values->{last_name} eq 'Smith') {
			return to_json {error => {last_name => "Family only!"}};
		}
		
		pass;
	};
	
	
	get '/User' => require_login sub {
		my (@languages, $errorMessage);
		my $class = 'User';
		$schema_info ||= TableEdit::SchemaInfo->new(schema => schema);
		my $columns = [map {$_->hashref} @{TableEdit::Routes::API::columns_info($class, TableEdit::Routes::API::class_form_columns($class))}];
		my $relationships = [map {$_->hashref} $schema_info->relationships($class)];

		return to_json({ 
			custom_information => 'this is custom!',
			fields => $columns,
			class => $class,
			class_label => $schema_info->{$class}->{label},
			relations => $relationships,
		}, {allow_unknown => 1}); 
	};

	1;

=cut	
