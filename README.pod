=encoding utf8

=pod
 
=head1 NAME
 
Dancer - Table Edit
 
=head1 SYNOPSIS
 
Table Edit lets you edit database data. It uses L<DBIx::Class> models for database metadata. 

 
=head1 CONFIGURATION
 
You need a database and L<DBIx::Class> models for this module to work. You can 
write your own L<DBIx::Class> models, or use schema loader.


=head2 DBIx schema loader

You can use your existing DBIx schema or let schema loader make one for you.

=head2 Database config

You also have to set the DBIC connection details in the
Dancer configuration (usually in the environments/*.yml
files as this differs between systems).

	plugins: 
	   DBIC:
	     default:
	        dsn: dbi:Pg:dbname=__DATABASE_NAME__;host=localhost;port=__PORT__
	        schema_class: TableEdit::Schema
	        user: __USERNAME__
	        pass: __PASSWORD__
	        options:
               pg_enable_utf8: 1

Make sure that you are using the appropriate UTF-8 flag for L<Dancer::Plugin::DBIC>, as
this plugin doesn't set it automatically.

=head1 FRONTEND

Table Edit uses L<Angular|http://angularjs.org/Angular> and L<Bootstrap|http://getbootstrap.com/> for the frontend.
It is easy to change the Bootstrap theme to get a different look for Table Edit.

=head1 USE

With basic configuration done you can start using Table Edit. You will probably want to fine tune it a bit though.
Table editor specific configuration is located in lib/config.yml.

=head1 FINE TUNE

For this example we will use following model and config file.

=head2 Model

	use utf8;
	package TableEdit::Schema::Result::User;
	
	use strict;
	use warnings;
	
	use base 'DBIx::Class::Core';
	
	__PACKAGE__->table("user");
	
	__PACKAGE__->add_columns(
	  "id",
	  { data_type => "integer", is_auto_increment => 1, is_nullable => 0 },
	  "username",
	  { data_type => "varchar", is_nullable => 0, size => 45 },
	  "email",
	  { data_type => "varchar", is_nullable => 1, size => 90 },
	  "description",
	  { data_type => "text", is_nullable => 1 },
	  "birthday",
	  { data_type => "timestamp with time zone", is_nullable => 1 },
	  "internal_code",
	  { data_type => "integer", is_nullable => 1 },
	  "created_date",
	  {
	    data_type     => "timestamp with time zone",
	    default_value => \"current_timestamp",
	    is_nullable   => 0,
	    original      => { default_value => \"now()" },
	  },
	);
	
	__PACKAGE__->set_primary_key("id");
	
	__PACKAGE__->belongs_to(
	  "company",
	  "TableEdit::Schema::Result::Company",
	  { id => "company_id" },
	  { is_deferrable => 1, on_delete => "CASCADE", on_update => "CASCADE" },
	);
	
	__PACKAGE__->has_many(
	  "user_items",
	  "TableEdit::Schema::Result::UserItem",
	  { "foreign.approval_id" => "self.approval_id" },
	  { cascade_copy => 0, cascade_delete => 0 },
	);
		
	__PACKAGE__->many_to_many("items", "user_items", "id", {class=>"Item",});
	
	# Created by DBIx::Class::Schema::Loader v0.07033
	# DO NOT MODIFY THIS OR ANYTHING ABOVE! md5sum:g5NE5itWUoKXqfEKXj/8Rg
	
	# You can replace this text with custom code or comments, and it will be preserved on regeneration
	1;

=head2 Config file
		
	TableEditor:
	  dropdown_treshold: 50
	  page_size: 10
	  
	  classes:
	    User: 
	      label: Employees
	      grid_columns: [users_id, username]
	      grid_sort: username
	      form_columns: [users_id, username, email]
	      to_string: | 
			 my $company = $self->company || "";
			 return "$self->username ($self->id) $company";
	      columns:
		     last_name:
			  label: 'Family name'			
			first_name:
			  label: 'Name'
			created_date:
			  readonly: 1
			  column_type = 'date'
			internal_code:
			  hidden: 1
			description:
			  column_type = 'html'
	    Order:
	      columns:
		payment_method: 
		  hidden: 1
		payment_status: 
		  readonly: 1

=head2 Global properties

=head3 Dropdown treshold

You can set number of rows that are still ok for dropdown. Tables with more than that will show items ID istead of dropdown by default.

	dropdown_treshold: 50
	
=head3 Page size

Number of items per page by default
	
	page_size: 10
	
=head3 Classes in menu

Order and selection of classes that show up in menu. Default are all classes with single primary key in alphabetical order.
	
	menu_classes: [user, product]
	
=head2 Class properties

Under classes you can specify class properties.

=head3 Label

Custom table lable. Default is generated from table name.

	label: Employees

=head3 Row in string representation

Row often has to be represented as string (titles, drop-down selectors, ...) so it is a good idea to 
define a custom, human readable stringification method. For example users username, his id in parentheses 
and company if he / she has one. It could be just username or something much complicated. 

variable $row is passed to script and it represents a row as DBIx::Class::Row object.
Snippet should return string.

	to_string: | 
		 my $company = $row->company || "";
		 return "$row->username ($row->id) $company";

=head3 Grid / form visible columns

Often you don't care about all columns when you browse though rows or there are simply to many. You can specify a list of columns that will appear on grid or form. You have to be careful not to omit required columns and similar on form view.

	grid_columns: [users_id, username]
	form_columns: [users_id, username, email]
	
=head3 Grid sort

By default list is not sorted. You can specify a default column. 
	
	grid_sort: username


=head2 Column properties


=head3 Label

You can override column label by specifying it  

	label: 'Family name'

=head3 Hidden columns

Some columns are used only internally and you never want to see them in TableEdit. You can hide them.

	hidden: 1

=head3 Readonly columns

You can set a column to be readonly in form view. 

	readonly = 1;

=head3 column data type

Columns have basic column types based on data types in db. You can override them to use different form element.
Available widgets are: boolean, date, datetime, dropdown, html, image_upload, integer, text, varchar

	column_type = 'html';

These column types are used on detail view and on list search. 	
	
=head4 Image upload

Example of image column conf:

	column_type: 'image_upload';
	upload_dir: 'lib_item_img/'; # default is "images/upload/$class/$column/"
	upload_max_size: 1000000; # in bytes, default is unlimited
	upload_extensions: ['jpg', 'jpeg', 'gif', 'PNG']; # case insensitive
 
=head1 PLUGINS
 
New functionalities and customization can be achieved by adding plugins.

=head2 Adding plugin

All plugins are located in /Plugins/name_of_plugin dir. Inside they usually have following stucture:

	Plugins
	|-Some_plugin
		|-api.pm
		|-public
			|-images
			|-js
				|-app.js
			|-views
	
URL to images folder is: 
api/plugins/Locator/public/images/

=head2 Activating plugin

Active plugins are listed in config.

	table_editor_plugins: [ "SomePlugin", "SomeOtherPlugin" ]

=head2 Custom pages

You can add new or redefine any page by adding custom route and redirect it to custom controller (or leave default) and custom template (or default). In js/app.js.

	custom_routes['/User/edit/:id'] = { templateUrl: '/api/plugins/SomePlugin/public/views/user-form.html', controller: 'UserEditCtrl' };
	
	var UserEditCtrl = function ($scope, $rootScope, $routeParams, Item, ClassItem, Url) {
		$scope.item = Item.read.get({
			class: 'User', 
			id: $routeParams.id}
		);
		$scope.data = ClassItem.get({class: 'User'});

		$scope.save = Item.update;
		$scope.related = Item.related_link;
	};

=head2 Custom API 

In api.pm routes can be overridden. This is useful for data manipulation before saving, data validation, custom information or similar. 


Example usage:

	package TableEdit::Plugins::SomePlugin::API;
	use Dancer ':syntax';


	prefix '/api';

	# Data validation
	post '/User' => sub {		
		my $post_data = from_json request->body;
		my $values = $post_data->{item}->{values};
		unless ($values->{last_name} eq 'Smith') {
			return to_json {error => {last_name => "Family only!"}};
		}
		
		pass;
	};
	
	
	get '/User' => require_login sub {
		my (@languages, $errorMessage);
		my $class = 'User';
		$schema_info ||= TableEdit::SchemaInfo->new(schema => schema);
		my $columns = [map {$_->hashref} @{TableEdit::Routes::API::columns_info($class, TableEdit::Routes::API::class_form_columns($class))}];
		my $relationships = [map {$_->hashref} $schema_info->relationships($class)];

		return to_json({ 
			custom_information => 'this is custom!',
			columns => $columns,
			class => $class,
			class_label => $schema_info->{$class}->{label},
			relations => $relationships,
		}, {allow_unknown => 1}); 
	};

	1;

=cut	
